/* Generated By:JavaCC: Do not edit this line. SACParserCSS2.java */
package com.steadystate.css.parser;

import org.w3c.css.sac.CSSParseException;
import org.w3c.css.sac.Condition;
import org.w3c.css.sac.LexicalUnit;
import org.w3c.css.sac.Locator;
import org.w3c.css.sac.Parser;
import org.w3c.css.sac.Selector;
import org.w3c.css.sac.SelectorList;
import org.w3c.css.sac.SimpleSelector;

/**
 * @author <a href="mailto:davidsch@users.sourceforge.net">David
 *         Schweinsberg</a>
 * @author waldbaer
 * @author rbri
 * @version $Id: SACParserCSS2.jj,v 1.8 2010-05-19 13:26:51 waldbaer Exp $
 */
public class SACParserCSS2 extends AbstractSACParser implements Parser, SACParserCSS2Constants {

	public SACParserCSS2() {
		this((CharStream) null);
	}

	public String getParserVersion() {
		return "http://www.w3.org/TR/REC-CSS2/";
	}

	protected String getGrammarUri() {
		return "http://www.w3.org/TR/REC-CSS2/grammar.html";
	}

	protected Token getToken() {
		return token;
	}

	//
	// stylesheet
	// : [ CHARSET_SYM S* STRING S* ';' ]?
	// [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
	// [ [ ruleset | media | page | font_face ] [S|CDO|CDC]* ]*
	// ;
	//
	final public void styleSheet() throws ParseException {
		try {
			handleStartDocument();
			styleSheetRuleList();
			jj_consume_token(0);
		} finally {
			handleEndDocument();
		}
	}

	final public void styleSheetRuleList() throws ParseException {
		boolean ruleFound = false;
		label_1: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
			case CDO:
			case CDC:
				;
				break;
			default:
				jj_la1[0] = jj_gen;
				break label_1;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
				jj_consume_token(S);
				break;
			case CDO:
				jj_consume_token(CDO);
				break;
			case CDC:
				jj_consume_token(CDC);
				break;
			default:
				jj_la1[1] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		}
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case CHARSET_SYM:
			charsetRule();
			label_2: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
				case CDO:
				case CDC:
					;
					break;
				default:
					jj_la1[2] = jj_gen;
					break label_2;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					jj_consume_token(S);
					break;
				case CDO:
					jj_consume_token(CDO);
					break;
				case CDC:
					jj_consume_token(CDC);
					break;
				default:
					jj_la1[3] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			break;
		default:
			jj_la1[4] = jj_gen;
			;
		}
		label_3: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case DOT:
			case COLON:
			case ASTERISK:
			case LSQUARE:
			case HASH:
			case IMPORT_SYM:
			case PAGE_SYM:
			case MEDIA_SYM:
			case FONT_FACE_SYM:
			case ATKEYWORD:
			case IDENT:
				;
				break;
			default:
				jj_la1[5] = jj_gen;
				break label_3;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IMPORT_SYM:
				importRule(ruleFound);
				break;
			case DOT:
			case COLON:
			case ASTERISK:
			case LSQUARE:
			case HASH:
			case PAGE_SYM:
			case MEDIA_SYM:
			case FONT_FACE_SYM:
			case ATKEYWORD:
			case IDENT:
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case DOT:
				case COLON:
				case ASTERISK:
				case LSQUARE:
				case HASH:
				case IDENT:
					styleRule();
					break;
				case MEDIA_SYM:
					mediaRule();
					break;
				case PAGE_SYM:
					pageRule();
					break;
				case FONT_FACE_SYM:
					fontFaceRule();
					break;
				case ATKEYWORD:
					unknownAtRule();
					break;
				default:
					jj_la1[6] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				ruleFound = true;
				break;
			default:
				jj_la1[7] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			label_4: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
				case CDO:
				case CDC:
					;
					break;
				default:
					jj_la1[8] = jj_gen;
					break label_4;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					jj_consume_token(S);
					break;
				case CDO:
					jj_consume_token(CDO);
					break;
				case CDC:
					jj_consume_token(CDC);
					break;
				default:
					jj_la1[9] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
		}
	}

	//
	// This is used by ASTStyleSheet.insertRule to parse a single rule
	//
	final public void styleSheetRuleSingle() throws ParseException {
		label_5: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
				;
				break;
			default:
				jj_la1[10] = jj_gen;
				break label_5;
			}
			jj_consume_token(S);
		}
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case CHARSET_SYM:
			charsetRule();
			break;
		case IMPORT_SYM:
			importRule(false);
			break;
		case DOT:
		case COLON:
		case ASTERISK:
		case LSQUARE:
		case HASH:
		case IDENT:
			styleRule();
			break;
		case MEDIA_SYM:
			mediaRule();
			break;
		case PAGE_SYM:
			pageRule();
			break;
		case FONT_FACE_SYM:
			fontFaceRule();
			break;
		case ATKEYWORD:
			unknownAtRule();
			break;
		default:
			jj_la1[11] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
	}

	final public void charsetRule() throws ParseException {
		Token t;
		Locator locator;
		try {
			jj_consume_token(CHARSET_SYM);
			locator = getLocator();
			label_6: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[12] = jj_gen;
					break label_6;
				}
				jj_consume_token(S);
			}
			t = jj_consume_token(STRING);
			label_7: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[13] = jj_gen;
					break label_7;
				}
				jj_consume_token(S);
			}
			jj_consume_token(SEMICOLON);
			handleCharset(t.toString(), locator);
		} catch (ParseException e) {
			getErrorHandler().error(toCSSParseException("invalidCharsetRule", e));
		}
	}

	final public void unknownAtRule() throws ParseException {
		String s;
		Locator locator;
		try {
			jj_consume_token(ATKEYWORD);
			locator = getLocator();
			s = skip();
			handleIgnorableAtRule(s, locator);
		} catch (ParseException e) {
			getErrorHandler().error(toCSSParseException("invalidUnknownRule", e));
		}
	}

	//
	// import
	// : IMPORT_SYM S*
	// [STRING|URI] S* [ medium [ ',' S* medium]* ]? ';' S*
	// ;
	//
	final public void importRule(final boolean nonImportRuleFoundBefore) throws ParseException {
		Token t;
		SACMediaListImpl ml = new SACMediaListImpl();
		Locator locator;
		try {
			jj_consume_token(IMPORT_SYM);
			locator = getLocator();
			label_8: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[14] = jj_gen;
					break label_8;
				}
				jj_consume_token(S);
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case STRING:
				t = jj_consume_token(STRING);
				break;
			case URI:
				t = jj_consume_token(URI);
				break;
			default:
				jj_la1[15] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			label_9: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[16] = jj_gen;
					break label_9;
				}
				jj_consume_token(S);
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IDENT:
				mediaList(ml);
				break;
			default:
				jj_la1[17] = jj_gen;
				;
			}
			jj_consume_token(SEMICOLON);
			if (nonImportRuleFoundBefore) {
				handleImportStyle(unescape(t.image, false), ml, null, locator);
			} else {
				handleImportStyle(unescape(t.image, false), ml, null, locator);
			}
		} catch (CSSParseException e) {
			getErrorHandler().error(e);
			error_skipAtRule();
		} catch (ParseException e) {
			getErrorHandler().error(toCSSParseException("invalidImportRule", e));
			error_skipAtRule();
		}
	}

	//
	// media
	// : MEDIA_SYM S* medium [ ',' S* medium ]* '{' S* ruleset* '}' S*
	// ;
	//
	final public void mediaRule() throws ParseException {
		boolean start = false;
		SACMediaListImpl ml = new SACMediaListImpl();
		Locator locator;
		try {
			jj_consume_token(MEDIA_SYM);
			locator = getLocator();
			label_10: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[18] = jj_gen;
					break label_10;
				}
				jj_consume_token(S);
			}
			mediaList(ml);
			start = true;
			handleStartMedia(ml, locator);
			jj_consume_token(LBRACE);
			label_11: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[19] = jj_gen;
					break label_11;
				}
				jj_consume_token(S);
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case DOT:
			case COLON:
			case ASTERISK:
			case LSQUARE:
			case HASH:
			case PAGE_SYM:
			case ATKEYWORD:
			case IDENT:
				mediaRuleList();
				break;
			default:
				jj_la1[20] = jj_gen;
				;
			}
			jj_consume_token(RBRACE);
		} catch (CSSParseException e) {
			getErrorHandler().error(e);
			error_skipblock();
		} catch (ParseException e) {
			CSSParseException cpe = toCSSParseException("invalidMediaRule", e);
			getErrorHandler().error(cpe);
			getErrorHandler().warning(createSkipWarning("ignoringRule", cpe));
			error_skipblock();
		} finally {
			if (start) {
				handleEndMedia(ml);
			}
		}
	}

	final public void mediaList(SACMediaListImpl ml) throws ParseException {
		String s;
		try {
			s = medium();
			ml.setLocator(getLocator());
			label_12: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case COMMA:
					;
					break;
				default:
					jj_la1[21] = jj_gen;
					break label_12;
				}
				jj_consume_token(COMMA);
				label_13: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[22] = jj_gen;
						break label_13;
					}
					jj_consume_token(S);
				}
				ml.add(s);
				s = medium();
			}
			ml.add(s);
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidMediaList", e);
			}
		}
	}

	final public void mediaRuleList() throws ParseException {
		label_14: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case DOT:
			case COLON:
			case ASTERISK:
			case LSQUARE:
			case HASH:
			case IDENT:
				styleRule();
				break;
			case PAGE_SYM:
				pageRule();
				break;
			case ATKEYWORD:
				unknownAtRule();
				break;
			default:
				jj_la1[23] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			label_15: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[24] = jj_gen;
					break label_15;
				}
				jj_consume_token(S);
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case DOT:
			case COLON:
			case ASTERISK:
			case LSQUARE:
			case HASH:
			case PAGE_SYM:
			case ATKEYWORD:
			case IDENT:
				;
				break;
			default:
				jj_la1[25] = jj_gen;
				break label_14;
			}
		}
	}

	//
	// medium
	// : IDENT S*
	// ;
	//
	final public String medium() throws ParseException {
		Token t;
		t = jj_consume_token(IDENT);
		label_16: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
				;
				break;
			default:
				jj_la1[26] = jj_gen;
				break label_16;
			}
			jj_consume_token(S);
		}
		handleMedium(t.image, createLocator(t));
		{
			return t.image;
		}

	}

	//
	// page
	// : PAGE_SYM S* IDENT? pseudo_page? S*
	// '{' S* declaration [ ';' S* declaration ]* '}' S*
	// ;
	//
	final public void pageRule() throws ParseException {
		Token t = null;
		String s = null;
		boolean start = false;
		Locator locator;
		try {
			jj_consume_token(PAGE_SYM);
			locator = getLocator();
			label_17: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[27] = jj_gen;
					break label_17;
				}
				jj_consume_token(S);
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case COLON:
			case IDENT:
				if (jj_2_1(2)) {
					t = jj_consume_token(IDENT);
					s = pseudoPage();
					label_18: while (true) {
						switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case S:
							;
							break;
						default:
							jj_la1[28] = jj_gen;
							break label_18;
						}
						jj_consume_token(S);
					}
				} else {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case IDENT:
						t = jj_consume_token(IDENT);
						label_19: while (true) {
							switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
							case S:
								;
								break;
							default:
								jj_la1[29] = jj_gen;
								break label_19;
							}
							jj_consume_token(S);
						}
						break;
					case COLON:
						s = pseudoPage();
						label_20: while (true) {
							switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
							case S:
								;
								break;
							default:
								jj_la1[30] = jj_gen;
								break label_20;
							}
							jj_consume_token(S);
						}
						break;
					default:
						jj_la1[31] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
				}
				break;
			default:
				jj_la1[32] = jj_gen;
				;
			}
			jj_consume_token(LBRACE);
			label_21: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[33] = jj_gen;
					break label_21;
				}
				jj_consume_token(S);
			}
			start = true;
			handleStartPage((t != null) ? unescape(t.image, false) : null, s, locator);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IDENT:
				declaration();
				break;
			default:
				jj_la1[34] = jj_gen;
				;
			}
			label_22: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case SEMICOLON:
					;
					break;
				default:
					jj_la1[35] = jj_gen;
					break label_22;
				}
				jj_consume_token(SEMICOLON);
				label_23: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[36] = jj_gen;
						break label_23;
					}
					jj_consume_token(S);
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case IDENT:
					declaration();
					break;
				default:
					jj_la1[37] = jj_gen;
					;
				}
			}
			jj_consume_token(RBRACE);
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidPageRule", e);
			}
		} finally {
			if (start) {
				handleEndPage((t != null) ? unescape(t.image, false) : null, s);
			}
		}
	}

	//
	// pseudoPage
	// : ':' IDENT
	// ;
	//
	final public String pseudoPage() throws ParseException {
		Token t;
		jj_consume_token(COLON);
		t = jj_consume_token(IDENT);
		{
			return unescape(t.image, false);
		}

	}

	//
	// font_face
	// : FONT_FACE_SYM S*
	// '{' S* declaration [ ';' S* declaration ]* '}' S*
	// ;
	//
	final public void fontFaceRule() throws ParseException {
		boolean start = false;
		Locator locator;
		try {
			jj_consume_token(FONT_FACE_SYM);
			locator = getLocator();
			label_24: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[38] = jj_gen;
					break label_24;
				}
				jj_consume_token(S);
			}
			jj_consume_token(LBRACE);
			label_25: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[39] = jj_gen;
					break label_25;
				}
				jj_consume_token(S);
			}
			start = true;
			handleStartFontFace(locator);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IDENT:
				declaration();
				break;
			default:
				jj_la1[40] = jj_gen;
				;
			}
			label_26: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case SEMICOLON:
					;
					break;
				default:
					jj_la1[41] = jj_gen;
					break label_26;
				}
				jj_consume_token(SEMICOLON);
				label_27: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[42] = jj_gen;
						break label_27;
					}
					jj_consume_token(S);
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case IDENT:
					declaration();
					break;
				default:
					jj_la1[43] = jj_gen;
					;
				}
			}
			jj_consume_token(RBRACE);
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidFontFaceRule", e);
			}
		} finally {
			if (start) {
				handleEndFontFace();
			}
		}
	}

	//
	// operator
	// : '/' S* | ',' S* |
	// ;
	//
	final public LexicalUnit operator(LexicalUnit prev) throws ParseException {
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case SLASH:
			jj_consume_token(SLASH);
			label_28: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[44] = jj_gen;
					break label_28;
				}
				jj_consume_token(S);
			} {
			return new LexicalUnitImpl(prev, LexicalUnit.SAC_OPERATOR_SLASH);
		}
		case COMMA:
			jj_consume_token(COMMA);
			label_29: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[45] = jj_gen;
					break label_29;
				}
				jj_consume_token(S);
			} {
			return LexicalUnitImpl.createComma(prev);
		}
		default:
			jj_la1[46] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}

	}

	//
	// combinator
	// : '+' S* | '>' S* |
	// ;
	//
	final public char combinator() throws ParseException {
		char c = ' ';
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case PLUS:
			jj_consume_token(PLUS);
			c = '+';
			label_30: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[47] = jj_gen;
					break label_30;
				}
				jj_consume_token(S);
			}
			break;
		case GT:
			jj_consume_token(GT);
			c = '>';
			label_31: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[48] = jj_gen;
					break label_31;
				}
				jj_consume_token(S);
			}
			break;
		case S:
			jj_consume_token(S);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case PLUS:
			case GT:
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case PLUS:
					jj_consume_token(PLUS);
					c = '+';
					break;
				case GT:
					jj_consume_token(GT);
					c = '>';
					break;
				default:
					jj_la1[49] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				label_32: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[50] = jj_gen;
						break label_32;
					}
					jj_consume_token(S);
				}
				break;
			default:
				jj_la1[51] = jj_gen;
				;
			}
			break;
		default:
			jj_la1[52] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		{
			return c;
		}

	}

	//
	// unary_operator
	// : '-' | '+'
	// ;
	//
	final public char unaryOperator() throws ParseException {
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case MINUS:
			jj_consume_token(MINUS); {
			return '-';
		}
		case PLUS:
			jj_consume_token(PLUS); {
			return '+';
		}
		default:
			jj_la1[53] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}

	}

	//
	// property
	// : IDENT S*
	// ;
	//
	final public String property() throws ParseException {
		Token t;
		t = jj_consume_token(IDENT);
		label_33: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
				;
				break;
			default:
				jj_la1[54] = jj_gen;
				break label_33;
			}
			jj_consume_token(S);
		}
		{
			return unescape(t.image, false);
		}

	}

	//
	// ruleset
	// : selector [ ',' S* selector ]*
	// '{' S* declaration [ ';' S* declaration ]* '}' S*
	// ;
	//
	final public void styleRule() throws ParseException {
		SelectorList selList = null;
		boolean start = false;
		Token t;
		try {
			t = getToken();
			selList = selectorList();
			jj_consume_token(LBRACE);
			label_34: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[55] = jj_gen;
					break label_34;
				}
				jj_consume_token(S);
			}
			start = true;
			handleStartSelector(selList, createLocator(t.next));
			styleDeclaration();
			jj_consume_token(RBRACE);
		} catch (CSSParseException e) {
			getErrorHandler().error(e);
			getErrorHandler().warning(createSkipWarning("ignoringRule", e));
			error_skipblock();
		} catch (ParseException e) {
			CSSParseException cpe = toCSSParseException("invalidStyleRule", e);
			getErrorHandler().error(cpe);
			getErrorHandler().warning(createSkipWarning("ignoringFollowingDeclarations", cpe));
			error_skipblock();
		} finally {
			if (start) {
				handleEndSelector(selList);
			}
		}
	}

	final public SelectorList parseSelectorsInternal() throws ParseException {
		SelectorList selectors;
		label_35: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
				;
				break;
			default:
				jj_la1[56] = jj_gen;
				break label_35;
			}
			jj_consume_token(S);
		}
		selectors = selectorList();
		jj_consume_token(0);
		{
			return selectors;
		}

	}

	final public SelectorList selectorList() throws ParseException {
		SelectorListImpl selList = new SelectorListImpl();
		Selector sel;
		sel = selector();
		if (sel instanceof Locatable) {
			selList.setLocator(((Locatable) sel).getLocator());
		}
		label_36: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case COMMA:
				;
				break;
			default:
				jj_la1[57] = jj_gen;
				break label_36;
			}
			jj_consume_token(COMMA);
			label_37: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[58] = jj_gen;
					break label_37;
				}
				jj_consume_token(S);
			}
			selList.add(sel);
			sel = selector();
		}
		selList.add(sel);
		{
			return selList;
		}

	}

	//
	// selector
	// : simple_selector [ combinator simple_selector ]*
	// ;
	//
	final public Selector selector() throws ParseException {
		Selector sel;
		char comb;
		try {
			sel = simpleSelector(null, ' ');
			label_38: while (true) {
				if (jj_2_2(2)) {
					;
				} else {
					break label_38;
				}
				comb = combinator();
				sel = simpleSelector(sel, comb);
			}
			label_39: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[59] = jj_gen;
					break label_39;
				}
				jj_consume_token(S);
			}
			handleSelector(sel);
			{
				return sel;
			}
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidSelector", e);
			}
		}

	}

	//
	// simple_selector
	// : element_name? [ HASH | class | attrib | pseudo ]* S*
	// ;
	//
	final public Selector simpleSelector(Selector sel, char comb) throws ParseException {
		SimpleSelector simpleSel = null;
		Condition c = null;
		SimpleSelector pseudoElementSel = null;
		Object o = null;
		try {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case ASTERISK:
			case IDENT:
				simpleSel = elementName();
				label_40: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case DOT:
					case COLON:
					case LSQUARE:
					case HASH:
						;
						break;
					default:
						jj_la1[60] = jj_gen;
						break label_40;
					}
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case HASH:
						c = hash(c, null != pseudoElementSel);
						break;
					case DOT:
						c = _class(c, null != pseudoElementSel);
						break;
					case LSQUARE:
						c = attrib(c, null != pseudoElementSel);
						break;
					case COLON:
						o = pseudo(c, null != pseudoElementSel);
						if (o instanceof Condition) {
							c = (Condition) o;
						} else {
							pseudoElementSel = (SimpleSelector) o;
						}
						break;
					default:
						jj_la1[61] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
				}
				break;
			case DOT:
			case COLON:
			case LSQUARE:
			case HASH:
				simpleSel = getSelectorFactory().createElementSelector(null, null);
				label_41: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case HASH:
						c = hash(c, null != pseudoElementSel);
						break;
					case DOT:
						c = _class(c, null != pseudoElementSel);
						break;
					case LSQUARE:
						c = attrib(c, null != pseudoElementSel);
						break;
					case COLON:
						o = pseudo(c, null != pseudoElementSel);
						if (o instanceof Condition) {
							c = (Condition) o;
						} else {
							pseudoElementSel = (SimpleSelector) o;
						}
						break;
					default:
						jj_la1[62] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case DOT:
					case COLON:
					case LSQUARE:
					case HASH:
						;
						break;
					default:
						jj_la1[63] = jj_gen;
						break label_41;
					}
				}
				break;
			default:
				jj_la1[64] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			if (c != null) {
				simpleSel = getSelectorFactory().createConditionalSelector(simpleSel, c);
			}

			if (sel == null) {
				sel = simpleSel;
			} else {
				switch (comb) {
				case ' ':
					sel = getSelectorFactory().createDescendantSelector(sel, simpleSel);
					break;
				case '+':
					sel = getSelectorFactory().createDirectAdjacentSelector(sel.getSelectorType(), sel, simpleSel);
					break;
				case '>':
					sel = getSelectorFactory().createChildSelector(sel, simpleSel);
					break;
				}
			}
			if (pseudoElementSel != null) {
				sel = getSelectorFactory().createDescendantSelector(sel, pseudoElementSel);
			}

			{
				return sel;
			}
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidSimpleSelector", e);
			}
		}

	}

	//
	// class
	// : '.' IDENT
	// ;
	//
	final public Condition _class(Condition pred, boolean pseudoElementFound) throws ParseException {
		Token t;
		Locator locator;
		ParseException pe = null;
		try {
			if (pseudoElementFound) {
				pe = generateParseException();
			}
			jj_consume_token(DOT);
			locator = getLocator();
			t = jj_consume_token(IDENT);
			if (pseudoElementFound) {
				{
					throw pe;
				}
			}
			Condition c = getConditionFactory().createClassCondition(null, t.image);
			if (c instanceof Locatable) {
				((Locatable) c).setLocator(locator);
			}
			{
				return (pred == null) ? c : getConditionFactory().createAndCondition(pred, c);
			}
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidClassSelector", e);
			}
		}

	}

	//
	// element_name
	// : IDENT | '*'
	// ;
	//
	final public SimpleSelector elementName() throws ParseException {
		Token t;
		SimpleSelector sel;
		try {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IDENT:
				t = jj_consume_token(IDENT);
				sel = getSelectorFactory().createElementSelector(null, unescape(t.image, false));
				if (sel instanceof Locatable) {
					((Locatable) sel).setLocator(getLocator());
				} {
				return sel;
			}
			case ASTERISK:
				jj_consume_token(ASTERISK);
				sel = getSelectorFactory().createElementSelector(null, null);
				if (sel instanceof Locatable) {
					((Locatable) sel).setLocator(getLocator());
				} {
				return sel;
			}
			default:
				jj_la1[65] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidElementName", e);
			}
		}

	}

	//
	// attrib
	// : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
	// [ IDENT | STRING ] S* ]? ']'
	// ;
	//
	final public Condition attrib(Condition pred, boolean pseudoElementFound) throws ParseException {
		Token t;
		String name = null;
		String value = null;
		int type = 0;
		Locator locator;
		try {
			jj_consume_token(LSQUARE);
			locator = getLocator();
			label_42: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[66] = jj_gen;
					break label_42;
				}
				jj_consume_token(S);
			}
			if (pseudoElementFound) {
				{
					throw generateParseException();
				}
			}
			t = jj_consume_token(IDENT);
			name = unescape(t.image, false);
			label_43: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[67] = jj_gen;
					break label_43;
				}
				jj_consume_token(S);
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case EQUALS:
			case INCLUDES:
			case DASHMATCH:
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EQUALS:
					jj_consume_token(EQUALS);
					type = 1;
					break;
				case INCLUDES:
					jj_consume_token(INCLUDES);
					type = 2;
					break;
				case DASHMATCH:
					jj_consume_token(DASHMATCH);
					type = 3;
					break;
				default:
					jj_la1[68] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				label_44: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[69] = jj_gen;
						break label_44;
					}
					jj_consume_token(S);
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case IDENT:
					t = jj_consume_token(IDENT);
					value = t.image;
					break;
				case STRING:
					t = jj_consume_token(STRING);
					value = unescape(t.image, false);
					break;
				default:
					jj_la1[70] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				label_45: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[71] = jj_gen;
						break label_45;
					}
					jj_consume_token(S);
				}
				break;
			default:
				jj_la1[72] = jj_gen;
				;
			}
			jj_consume_token(RSQUARE);
			Condition c = null;
			switch (type) {
			case 0:
				c = getConditionFactory().createAttributeCondition(name, null, false, null);
				break;
			case 1:
				c = getConditionFactory().createAttributeCondition(name, null, null != value, value);
				break;
			case 2:
				c = getConditionFactory().createOneOfAttributeCondition(name, null, null != value, value);
				break;
			case 3:
				c = getConditionFactory().createBeginHyphenAttributeCondition(name, null, null != value, value);
				break;
			}
			if (c instanceof Locatable) {
				((Locatable) c).setLocator(locator);
			}
			{
				return (pred == null) ? c : getConditionFactory().createAndCondition(pred, c);
			}
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidAttrib", e);
			}
		}

	}

	//
	// pseudo
	// : ':' [ IDENT
	// | FUNCTION_LANG S* IDENT S* ')'
	// | FUNCTION S* IDENT S* ')'
	// ]
	// ;
	//
	final public Object pseudo(Condition pred, boolean pseudoElementFound) throws ParseException {
		SimpleSelector pseudoElementSel = null;
		Condition c = null;
		Token t;
		String function;
		String arg = "";
		Locator locator;
		try {
			jj_consume_token(COLON);
			locator = getLocator();
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IDENT:
				t = jj_consume_token(IDENT);
				String s = unescape(t.image, false);
				if (pseudoElementFound) {
					{
						throw toCSSParseException("duplicatePseudo", new String[] { s }, locator);
					}
				}
				if ("first-line".equals(s) || "first-letter".equals(s) || "before".equals(s) || "after".equals(s)) {
					pseudoElementSel = getSelectorFactory().createPseudoElementSelector(null, s);
					if (pseudoElementSel instanceof Locatable) {
						((Locatable) pseudoElementSel).setLocator(locator);
					}
					{
						return pseudoElementSel;
					}
				}
				c = getConditionFactory().createPseudoClassCondition(null, s);
				if (c instanceof Locatable) {
					((Locatable) c).setLocator(locator);
				} {
				return (pred == null) ? c : getConditionFactory().createAndCondition(pred, c);
			}
			case FUNCTION_LANG:
				t = jj_consume_token(FUNCTION_LANG);
				function = unescape(t.image, false);
				label_46: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[73] = jj_gen;
						break label_46;
					}
					jj_consume_token(S);
				}
				t = jj_consume_token(IDENT);
				String lang = unescape(t.image, false);
				label_47: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[74] = jj_gen;
						break label_47;
					}
					jj_consume_token(S);
				}
				jj_consume_token(RROUND);
				if (pseudoElementFound) {
					{
						throw toCSSParseException("duplicatePseudo", new String[] { "lang(" + lang + ")" }, locator);
					}
				}
				c = getConditionFactory().createLangCondition(lang);
				if (c instanceof Locatable) {
					((Locatable) c).setLocator(locator);
				} {
				return (pred == null) ? c : getConditionFactory().createAndCondition(pred, c);
			}
			case FUNCTION:
				t = jj_consume_token(FUNCTION);
				function = unescape(t.image, false);
				label_48: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[75] = jj_gen;
						break label_48;
					}
					jj_consume_token(S);
				}
				t = jj_consume_token(IDENT);
				arg = unescape(t.image, false);
				label_49: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[76] = jj_gen;
						break label_49;
					}
					jj_consume_token(S);
				}
				jj_consume_token(RROUND);
				if (pseudoElementFound) {
					{
						throw toCSSParseException("duplicatePseudo", new String[] { function + arg + ")" }, locator);
					}
				}
				c = getConditionFactory().createPseudoClassCondition(null, function + arg + ")");
				if (c instanceof Locatable) {
					((Locatable) c).setLocator(locator);
				} {
				return (pred == null) ? c : getConditionFactory().createAndCondition(pred, c);
			}
			default:
				jj_la1[77] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidPseudo", e);
			}
		}

	}

	final public Condition hash(Condition pred, boolean pseudoElementFound) throws ParseException {
		Token t;
		ParseException pe = null;
		try {
			if (pseudoElementFound) {
				pe = generateParseException();
			}
			t = jj_consume_token(HASH);
			if (pseudoElementFound) {
				{
					throw pe;
				}
			}
			Condition c = getConditionFactory().createIdCondition(unescape(t.image.substring(1), false));
			if (c instanceof Locatable) {
				((Locatable) c).setLocator(getLocator());
			}
			{
				return (pred == null) ? c : getConditionFactory().createAndCondition(pred, c);
			}
		} catch (ParseException e) {
			{
				throw toCSSParseException("invalidHash", e);
			}
		}

	}

	final public void styleDeclaration() throws ParseException {
		try {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IDENT:
				declaration();
				break;
			default:
				jj_la1[78] = jj_gen;
				;
			}
			label_50: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case SEMICOLON:
					;
					break;
				default:
					jj_la1[79] = jj_gen;
					break label_50;
				}
				jj_consume_token(SEMICOLON);
				label_51: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case S:
						;
						break;
					default:
						jj_la1[80] = jj_gen;
						break label_51;
					}
					jj_consume_token(S);
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case IDENT:
					declaration();
					break;
				default:
					jj_la1[81] = jj_gen;
					;
				}
			}
		} catch (ParseException ex) {
			CSSParseException cpe = toCSSParseException("invalidDeclaration", ex);
			getErrorHandler().error(cpe);
			error_skipdecl();
		}
	}

	//
	// declaration
	// : property ':' S* expr prio?
	// |
	// ;
	//
	final public void declaration() throws ParseException {
		String p;
		LexicalUnit e;
		boolean priority = false;
		Locator locator = null;
		try {
			p = property();
			locator = getLocator();
			jj_consume_token(COLON);
			label_52: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case S:
					;
					break;
				default:
					jj_la1[82] = jj_gen;
					break label_52;
				}
				jj_consume_token(S);
			}
			e = expr();
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IMPORTANT_SYM:
				priority = prio();
				break;
			default:
				jj_la1[83] = jj_gen;
				;
			}
			handleProperty(p, e, priority, locator);
		} catch (CSSParseException ex) {
			getErrorHandler().error(ex);
			getErrorHandler().warning(createSkipWarning("ignoringFollowingDeclarations", ex));
			error_skipdecl();
		} catch (ParseException ex) {
			CSSParseException cpe = toCSSParseException("invalidDeclaration", ex);
			getErrorHandler().error(cpe);
			error_skipdecl();
		}
	}

	//
	// prio
	// : IMPORTANT_SYM S*
	// ;
	final public boolean prio() throws ParseException {
		jj_consume_token(IMPORTANT_SYM);
		label_53: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
				;
				break;
			default:
				jj_la1[84] = jj_gen;
				break label_53;
			}
			jj_consume_token(S);
		}
		return true;
	}

	//
	// expr
	// : term [ operator term ]*
	// ;
	//
	// TODO: Deal with the operator
	//
	final public LexicalUnit expr() throws ParseException {
		LexicalUnit head;
		LexicalUnit body;
		try {
			head = term(null);
			body = head;
			label_54: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case COMMA:
				case SLASH:
				case PLUS:
				case MINUS:
				case HASH:
				case STRING:
				case URI:
				case INHERIT:
				case EMS:
				case EXS:
				case LENGTH_PX:
				case LENGTH_CM:
				case LENGTH_MM:
				case LENGTH_IN:
				case LENGTH_PT:
				case LENGTH_PC:
				case ANGLE_DEG:
				case ANGLE_RAD:
				case ANGLE_GRAD:
				case TIME_MS:
				case TIME_S:
				case FREQ_HZ:
				case FREQ_KHZ:
				case PERCENTAGE:
				case DIMEN:
				case NUMBER:
				case RGB:
				case FUNCTION:
				case IDENT:
				case UNICODERANGE:
					;
					break;
				default:
					jj_la1[85] = jj_gen;
					break label_54;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case COMMA:
				case SLASH:
					body = operator(body);
					break;
				default:
					jj_la1[86] = jj_gen;
					;
				}
				body = term(body);
			}
			{
				return head;
			}
		} catch (ParseException ex) {
			{
				throw toCSSParseException("invalidExpr", ex);
			}
		}

	}

	//
	// term
	// : unary_operator?
	// [ NUMBER | PERCENTAGE | LENGTH | EMS | EXS | ANGLE | TIME | FREQ |
	// function ]
	// | STRING | IDENT | URI | RGB | UNICODERANGE | hexcolor | DIMEN
	// S*
	// ;
	//
	final public LexicalUnit term(LexicalUnit prev) throws ParseException {
		Token t;
		char op = ' ';
		LexicalUnit value = null;
		Locator locator = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case PLUS:
		case MINUS:
			op = unaryOperator();
			break;
		default:
			jj_la1[87] = jj_gen;
			;
		}
		if (op != ' ') {
			locator = getLocator();
		}
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case EMS:
		case EXS:
		case LENGTH_PX:
		case LENGTH_CM:
		case LENGTH_MM:
		case LENGTH_IN:
		case LENGTH_PT:
		case LENGTH_PC:
		case ANGLE_DEG:
		case ANGLE_RAD:
		case ANGLE_GRAD:
		case TIME_MS:
		case TIME_S:
		case FREQ_HZ:
		case FREQ_KHZ:
		case PERCENTAGE:
		case NUMBER:
		case FUNCTION:
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case NUMBER:
				t = jj_consume_token(NUMBER);
				try {
					value = LexicalUnitImpl.createNumber(prev, intValue(op, t.image));
				} catch (NumberFormatException e) {
					value = LexicalUnitImpl.createNumber(prev, floatValue(op, t.image));
				}
				break;
			case PERCENTAGE:
				t = jj_consume_token(PERCENTAGE);
				value = LexicalUnitImpl.createPercentage(prev, floatValue(op, t.image));
				break;
			case LENGTH_PX:
				t = jj_consume_token(LENGTH_PX);
				value = LexicalUnitImpl.createPixel(prev, floatValue(op, t.image));
				break;
			case LENGTH_CM:
				t = jj_consume_token(LENGTH_CM);
				value = LexicalUnitImpl.createCentimeter(prev, floatValue(op, t.image));
				break;
			case LENGTH_MM:
				t = jj_consume_token(LENGTH_MM);
				value = LexicalUnitImpl.createMillimeter(prev, floatValue(op, t.image));
				break;
			case LENGTH_IN:
				t = jj_consume_token(LENGTH_IN);
				value = LexicalUnitImpl.createInch(prev, floatValue(op, t.image));
				break;
			case LENGTH_PT:
				t = jj_consume_token(LENGTH_PT);
				value = LexicalUnitImpl.createPoint(prev, floatValue(op, t.image));
				break;
			case LENGTH_PC:
				t = jj_consume_token(LENGTH_PC);
				value = LexicalUnitImpl.createPica(prev, floatValue(op, t.image));
				break;
			case EMS:
				t = jj_consume_token(EMS);
				value = LexicalUnitImpl.createEm(prev, floatValue(op, t.image));
				break;
			case EXS:
				t = jj_consume_token(EXS);
				value = LexicalUnitImpl.createEx(prev, floatValue(op, t.image));
				break;
			case ANGLE_DEG:
				t = jj_consume_token(ANGLE_DEG);
				value = LexicalUnitImpl.createDegree(prev, floatValue(op, t.image));
				break;
			case ANGLE_RAD:
				t = jj_consume_token(ANGLE_RAD);
				value = LexicalUnitImpl.createRadian(prev, floatValue(op, t.image));
				break;
			case ANGLE_GRAD:
				t = jj_consume_token(ANGLE_GRAD);
				value = LexicalUnitImpl.createGradian(prev, floatValue(op, t.image));
				break;
			case TIME_MS:
				t = jj_consume_token(TIME_MS);
				value = LexicalUnitImpl.createMillisecond(prev, floatValue(op, t.image));
				break;
			case TIME_S:
				t = jj_consume_token(TIME_S);
				value = LexicalUnitImpl.createSecond(prev, floatValue(op, t.image));
				break;
			case FREQ_HZ:
				t = jj_consume_token(FREQ_HZ);
				value = LexicalUnitImpl.createHertz(prev, floatValue(op, t.image));
				break;
			case FREQ_KHZ:
				t = jj_consume_token(FREQ_KHZ);
				value = LexicalUnitImpl.createKiloHertz(prev, floatValue(op, t.image));
				break;
			case FUNCTION:
				value = function(prev);
				break;
			default:
				jj_la1[88] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			break;
		case STRING:
			t = jj_consume_token(STRING);
			value = LexicalUnitImpl.createString(prev, unescape(t.image, false));
			break;
		case IDENT:
			t = jj_consume_token(IDENT);
			value = LexicalUnitImpl.createIdent(prev, unescape(t.image, false));
			break;
		case URI:
			t = jj_consume_token(URI);
			value = LexicalUnitImpl.createURI(prev, t.image);
			break;
		case UNICODERANGE:
			t = jj_consume_token(UNICODERANGE);
			value = new LexicalUnitImpl(prev, LexicalUnit.SAC_UNICODERANGE, t.image);
			break;
		case RGB:
			value = rgb(prev);
			break;
		case HASH:
			value = hexcolor(prev);
			break;
		case DIMEN:
			t = jj_consume_token(DIMEN);
			int n = getLastNumPos(t.image);
			value = LexicalUnitImpl.createDimension(prev, floatValue(op, t.image.substring(0, n + 1)),
					t.image.substring(n + 1));
			break;
		case INHERIT:
			t = jj_consume_token(INHERIT);
			value = new LexicalUnitImpl(prev, LexicalUnit.SAC_INHERIT, t.image);
			break;
		default:
			jj_la1[89] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		if (locator == null) {
			locator = getLocator();
		}
		label_55: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
				;
				break;
			default:
				jj_la1[90] = jj_gen;
				break label_55;
			}
			jj_consume_token(S);
		}
		if (value instanceof Locatable) {
			((Locatable) value).setLocator(locator);
		}
		{
			return value;
		}

	}

	//
	// function
	// : FUNCTION S* expr ')' S*
	// ;
	//
	final public LexicalUnit function(LexicalUnit prev) throws ParseException {
		Token t;
		LexicalUnit params;
		t = jj_consume_token(FUNCTION);
		label_56: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
				;
				break;
			default:
				jj_la1[91] = jj_gen;
				break label_56;
			}
			jj_consume_token(S);
		}
		params = expr();
		jj_consume_token(RROUND);
		{
			return functionInternal(prev, t.image, params);
		}
	}

	//
	// rgb
	// : RGB S* expr ')' S*
	// ;
	//
	final public LexicalUnit rgb(LexicalUnit prev) throws ParseException {
		LexicalUnit params;
		jj_consume_token(RGB);
		label_57: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case S:
				;
				break;
			default:
				jj_la1[92] = jj_gen;
				break label_57;
			}
			jj_consume_token(S);
		}
		params = expr();
		jj_consume_token(RROUND);
		{
			return LexicalUnitImpl.createRgbColor(prev, params);
		}

	}

	//
	// hexcolor
	// : HASH S*
	// ;
	//
	final public LexicalUnit hexcolor(LexicalUnit prev) throws ParseException {
		Token t;
		t = jj_consume_token(HASH);
		{
			return hexcolorInternal(prev, t);
		}
	}

	String skip() throws ParseException {
		StringBuilder sb = new StringBuilder();
		int nesting = 0;
		Token t = getToken(0);
		if (t.image != null) {
			sb.append(t.image);
		}
		do {
			t = getNextToken();
			if (t.kind == EOF)
				break;
			sb.append(t.image);
			if (t.kind == LBRACE)
				nesting++;
			else if (t.kind == RBRACE)
				nesting--;
			else if (t.kind == SEMICOLON && nesting <= 0)
				break;
		} while ((t.kind != RBRACE) || (nesting > 0));

		return sb.toString();
	}

	void error_skipblock() throws ParseException {
		Token t;
		int nesting = 0;
		do {
			t = getNextToken();
			if (t.kind == LBRACE) {
				nesting++;
			} else if (t.kind == RBRACE) {
				nesting--;
			} else if (t.kind == EOF) {
				break;
			}
		} while ((t.kind != RBRACE) || (nesting > 0));
	}

	void error_skipdecl() throws ParseException {
		Token t = getToken(1);
		if (t.kind == LBRACE) {
			error_skipblock();
		} else {
			Token oldToken = token;
			while (t.kind != SEMICOLON && t.kind != RBRACE && t.kind != EOF) {
				oldToken = t;
				t = getNextToken();
			}
			if (t.kind != EOF) {
				token = oldToken;
			}
		}
	}

	void error_skipAtRule() throws ParseException {
		Token t = null;
		do {
			t = getNextToken();
		} while (t.kind != SEMICOLON && t.kind != EOF);
	}

	private boolean jj_2_1(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_1();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(0, xla);
		}
	}

	private boolean jj_2_2(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_2();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(1, xla);
		}
	}

	private boolean jj_3R_76() {
		if (jj_3R_80())
			return true;
		return false;
	}

	private boolean jj_3R_75() {
		if (jj_3R_79())
			return true;
		return false;
	}

	private boolean jj_3R_78() {
		if (jj_scan_token(DOT))
			return true;
		return false;
	}

	private boolean jj_3R_74() {
		if (jj_3R_78())
			return true;
		return false;
	}

	private boolean jj_3R_73() {
		if (jj_3R_77())
			return true;
		return false;
	}

	private boolean jj_3R_68() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_73()) {
			jj_scanpos = xsp;
			if (jj_3R_74()) {
				jj_scanpos = xsp;
				if (jj_3R_75()) {
					jj_scanpos = xsp;
					if (jj_3R_76())
						return true;
				}
			}
		}
		return false;
	}

	private boolean jj_3_2() {
		if (jj_3R_59())
			return true;
		if (jj_3R_60())
			return true;
		return false;
	}

	private boolean jj_3R_71() {
		if (jj_scan_token(IDENT))
			return true;
		return false;
	}

	private boolean jj_3R_77() {
		if (jj_scan_token(HASH))
			return true;
		return false;
	}

	private boolean jj_3R_65() {
		Token xsp;
		if (jj_3R_68())
			return true;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_68()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_58() {
		if (jj_scan_token(COLON))
			return true;
		return false;
	}

	private boolean jj_3R_70() {
		if (jj_scan_token(GT))
			return true;
		return false;
	}

	private boolean jj_3R_67() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_71()) {
			jj_scanpos = xsp;
			if (jj_3R_72())
				return true;
		}
		return false;
	}

	private boolean jj_3R_79() {
		if (jj_scan_token(LSQUARE))
			return true;
		return false;
	}

	private boolean jj_3R_64() {
		if (jj_3R_67())
			return true;
		return false;
	}

	private boolean jj_3R_69() {
		if (jj_scan_token(PLUS))
			return true;
		return false;
	}

	private boolean jj_3R_66() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_69()) {
			jj_scanpos = xsp;
			if (jj_3R_70())
				return true;
		}
		return false;
	}

	private boolean jj_3R_60() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_64()) {
			jj_scanpos = xsp;
			if (jj_3R_65())
				return true;
		}
		return false;
	}

	private boolean jj_3R_80() {
		if (jj_scan_token(COLON))
			return true;
		return false;
	}

	private boolean jj_3_1() {
		if (jj_scan_token(IDENT))
			return true;
		if (jj_3R_58())
			return true;
		return false;
	}

	private boolean jj_3R_63() {
		if (jj_scan_token(S))
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_66())
			jj_scanpos = xsp;
		return false;
	}

	private boolean jj_3R_62() {
		if (jj_scan_token(GT))
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_scan_token(1)) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_72() {
		if (jj_scan_token(ASTERISK))
			return true;
		return false;
	}

	private boolean jj_3R_61() {
		if (jj_scan_token(PLUS))
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_scan_token(1)) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_59() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_61()) {
			jj_scanpos = xsp;
			if (jj_3R_62()) {
				jj_scanpos = xsp;
				if (jj_3R_63())
					return true;
			}
		}
		return false;
	}

	/** Generated Token Manager. */
	public SACParserCSS2TokenManager token_source;
	/** Current token. */
	public Token token;
	/** Next token. */
	public Token jj_nt;
	private int jj_ntk;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	private int jj_gen;
	final private int[] jj_la1 = new int[93];
	static private int[] jj_la1_0;
	static private int[] jj_la1_1;
	static private int[] jj_la1_2;

	static {
		jj_la1_init_0();
		jj_la1_init_1();
		jj_la1_init_2();
	}

	private static void jj_la1_init_0() {
		jj_la1_0 = new int[] { 0x6000002, 0x6000002, 0x6000002, 0x6000002, 0x0, 0xe0141a00, 0xc0141a00, 0xe0141a00,
				0x6000002, 0x6000002, 0x2, 0xe0141a00, 0x2, 0x2, 0x2, 0x1200000, 0x2, 0x0, 0x2, 0x2, 0x40141a00, 0x100,
				0x2, 0x40141a00, 0x2, 0x40141a00, 0x2, 0x2, 0x2, 0x2, 0x2, 0x800, 0x800, 0x2, 0x0, 0x400, 0x2, 0x0, 0x2,
				0x2, 0x0, 0x400, 0x2, 0x0, 0x2, 0x2, 0x2100, 0x2, 0x2, 0x24000, 0x2, 0x24000, 0x24002, 0xc000, 0x2, 0x2,
				0x2, 0x100, 0x2, 0x2, 0x140a00, 0x140a00, 0x140a00, 0x140a00, 0x141a00, 0x1000, 0x2, 0x2, 0x18010000,
				0x2, 0x200000, 0x2, 0x18010000, 0x2, 0x2, 0x2, 0x2, 0x0, 0x0, 0x400, 0x2, 0x0, 0x2, 0x0, 0x2, 0x130e100,
				0x2100, 0xc000, 0x0, 0x1300000, 0x2, 0x2, 0x2, };
	}

	private static void jj_la1_init_1() {
		jj_la1_1 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x2, 0x4000005, 0x4000005, 0x4000005, 0x0, 0x0, 0x0, 0x4000007, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x4000000, 0x0, 0x0, 0x4000004, 0x0, 0x0, 0x4000004, 0x0, 0x4000004, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x4000000, 0x4000000, 0x0, 0x4000000, 0x0, 0x0, 0x4000000, 0x0, 0x0, 0x4000000, 0x0, 0x0,
				0x4000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x4000000, 0x4000000, 0x0, 0x0, 0x0, 0x0, 0x4000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7000000,
				0x4000000, 0x0, 0x0, 0x4000000, 0x0, 0x8, 0x0, 0x26fffff0, 0x0, 0x0, 0x25fffe0, 0x26fffff0, 0x0, 0x0,
				0x0, };
	}

	private static void jj_la1_init_2() {
		jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
	}

	final private JJCalls[] jj_2_rtns = new JJCalls[2];
	private boolean jj_rescan = false;
	private int jj_gc = 0;

	/** Constructor with user supplied CharStream. */
	public SACParserCSS2(CharStream stream) {
		token_source = new SACParserCSS2TokenManager(stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 93; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(CharStream stream) {
		token_source.ReInit(stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 93; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Constructor with generated Token Manager. */
	public SACParserCSS2(SACParserCSS2TokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 93; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(SACParserCSS2TokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 93; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	private Token jj_consume_token(int kind) throws ParseException {
		Token oldToken;
		if ((oldToken = token).next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if (token.kind == kind) {
			jj_gen++;
			if (++jj_gc > 100) {
				jj_gc = 0;
				for (int i = 0; i < jj_2_rtns.length; i++) {
					JJCalls c = jj_2_rtns[i];
					while (c != null) {
						if (c.gen < jj_gen)
							c.first = null;
						c = c.next;
					}
				}
			}
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	static private final class LookaheadSuccess extends java.lang.Error {

		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
	}

	final private LookaheadSuccess jj_ls = new LookaheadSuccess();

	private boolean jj_scan_token(int kind) {
		if (jj_scanpos == jj_lastpos) {
			jj_la--;
			if (jj_scanpos.next == null) {
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
			} else {
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		} else {
			jj_scanpos = jj_scanpos.next;
		}
		if (jj_rescan) {
			int i = 0;
			Token tok = token;
			while (tok != null && tok != jj_scanpos) {
				i++;
				tok = tok.next;
			}
			if (tok != null)
				jj_add_error_token(kind, i);
		}
		if (jj_scanpos.kind != kind)
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			throw jj_ls;
		return false;
	}

	/** Get the next Token. */
	final public Token getNextToken() {
		if (token.next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		return token;
	}

	/** Get the specific Token. */
	final public Token getToken(int index) {
		Token t = token;
		for (int i = 0; i < index; i++) {
			if (t.next != null)
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}

	private int jj_ntk() {
		if ((jj_nt = token.next) == null)
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		else
			return (jj_ntk = jj_nt.kind);
	}

	private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private int[] jj_lasttokens = new int[100];
	private int jj_endpos;

	private void jj_add_error_token(int kind, int pos) {
		if (pos >= 100)
			return;
		if (pos == jj_endpos + 1) {
			jj_lasttokens[jj_endpos++] = kind;
		} else if (jj_endpos != 0) {
			jj_expentry = new int[jj_endpos];
			for (int i = 0; i < jj_endpos; i++) {
				jj_expentry[i] = jj_lasttokens[i];
			}
			jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
				int[] oldentry = (int[]) (it.next());
				if (oldentry.length == jj_expentry.length) {
					for (int i = 0; i < jj_expentry.length; i++) {
						if (oldentry[i] != jj_expentry[i]) {
							continue jj_entries_loop;
						}
					}
					jj_expentries.add(jj_expentry);
					break jj_entries_loop;
				}
			}
			if (pos != 0)
				jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		}
	}

	/** Generate ParseException. */
	public ParseException generateParseException() {
		jj_expentries.clear();
		boolean[] la1tokens = new boolean[80];
		if (jj_kind >= 0) {
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for (int i = 0; i < 93; i++) {
			if (jj_la1[i] == jj_gen) {
				for (int j = 0; j < 32; j++) {
					if ((jj_la1_0[i] & (1 << j)) != 0) {
						la1tokens[j] = true;
					}
					if ((jj_la1_1[i] & (1 << j)) != 0) {
						la1tokens[32 + j] = true;
					}
					if ((jj_la1_2[i] & (1 << j)) != 0) {
						la1tokens[64 + j] = true;
					}
				}
			}
		}
		for (int i = 0; i < 80; i++) {
			if (la1tokens[i]) {
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.add(jj_expentry);
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		int[][] exptokseq = new int[jj_expentries.size()][];
		for (int i = 0; i < jj_expentries.size(); i++) {
			exptokseq[i] = jj_expentries.get(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}

	/** Enable tracing. */
	final public void enable_tracing() {
	}

	/** Disable tracing. */
	final public void disable_tracing() {
	}

	private void jj_rescan_token() {
		jj_rescan = true;
		for (int i = 0; i < 2; i++) {
			try {
				JJCalls p = jj_2_rtns[i];
				do {
					if (p.gen > jj_gen) {
						jj_la = p.arg;
						jj_lastpos = jj_scanpos = p.first;
						switch (i) {
						case 0:
							jj_3_1();
							break;
						case 1:
							jj_3_2();
							break;
						}
					}
					p = p.next;
				} while (p != null);
			} catch (LookaheadSuccess ls) {
			}
		}
		jj_rescan = false;
	}

	private void jj_save(int index, int xla) {
		JJCalls p = jj_2_rtns[index];
		while (p.gen > jj_gen) {
			if (p.next == null) {
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}

	static final class JJCalls {
		int gen;
		Token first;
		int arg;
		JJCalls next;
	}

}
